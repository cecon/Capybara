<?xml version="1.0" encoding="UTF-8"?>
<cappy:script name="newtask" version="1.2">
  <about>
    <summary>Preparar (não executar) uma nova task atômica via fluxo "scope-first".</summary>
    <command>#newtask</command>
    <notes>
      <note>Fluxo em pt-BR. Não implemente código; apenas crie o arquivo da task.</note>
      <note>Escopo atômico: 2-3 horas no máximo.</note>
      <note>Exige KnowStack validado em .cappy/config.* antes de qualquer pergunta de escopo.</note>
    </notes>
  </about>

  <steps>
    <step id="1.check_active">
      <goal>Check for active or paused tasks using VSCode Command getActiveTask; ask to pause if one exists.</goal>
      <logic>
        <![CDATA[
        activeTaskText = vscode_command("cappy.getActiveTask")
        if (activeTaskText && !activeTaskText.includes("não tem uma task ativa")) {
          ask_user("Há uma task ativa: '" + activeTaskText + "'. Pausar para criar uma nova? (sim/não)")
          if (user_answer == "não") return
        }
        ]]>
      </logic>
      <logic>
        <![CDATA[
        tasks = list_files(".cappy/tasks/*.xml")
        for (t in tasks) {
          x = read_xml(t)
          if (x.metadata.status in ["in-progress", "preparing", "paused"]) {
            ask_user("Há uma task ativa: '" + x.metadata.title + "'. Pausar para criar uma nova? (sim/não)")
            if (user_answer == "no") return
          }
        }
        ]]>
      </logic>
    </step>

    <step id="2.context_read">
      <goal>Carregar contexto mínimo a partir de .cappy/config.* e validar KnowStack.</goal>
      <logic>
        <![CDATA[
        prevention_rules = optional_read(".cappy/prevention-rules.md")
        project_config   = required_read(".cappy/config.yaml|.cappy/config.json")
        patterns         = optional_read(".cappy/instructions/cappy-patterns.md")

        // Fonte da stack e validação devem vir do .cappy/config.*
        stack_path      = extract_yaml_value(project_config, "stack.source") || ".cappy/stack.md"
        stack_validated = extract_yaml_value(project_config, "stack.validated") == true
        stack_md        = optional_read(stack_path)

        if (!stack_validated || !stack_md) {
          stop_with_message("KnowStack não finalizado. Execute 'cappy:knowstack' para criar/validar .cappy/stack.md e .cappy/config.yaml.")
        }

        // Preferência de idioma (default pt-BR)
        lang = extract_yaml_value(project_config, "language") || "pt-BR"
        ]]>
      </logic>
    </step>

    <step id="3.atomicity_gate">
      <goal>Ensure the requested task is atomic; suggest decomposition otherwise.</goal>
      <logic>
        <![CDATA[
        if (estimated_effort_hours > 3) {
          suggest_decomposition_using(patterns)
          stop_with_message("Task não criada: escopo não é atômico. Divida em steps menores.")
        }
        ]]>
      </logic>
    </step>

    <step id="4.collect_min_fields">
      <goal>Coletar informações mínimas pelo fluxo "scope-first" (sem exigir título).</goal>
      <inputs>
        <arg name="title" required="false" example="Configurar autenticação Supabase" />
        <arg name="scope" required="false" example="Criar endpoint de login com validação JWT e testes" />
        <arg name="area"  required="false" values="frontend,backend,fullstack,mobile,devops" />
        <arg name="tech"  required="false" example="nodejs" />
        <arg name="description" required="false" />
      </inputs>
      <logic>
        <![CDATA[
        // Se não houver título, conduzir perguntas de escopo em pt-BR
        if (!args.title) {
          q = [
            "Qual é o escopo da nova task? Resuma em 1-2 linhas.",
            "Quais são os critérios de aceitação (o que define 'pronto')?",
            "Quais áreas serão afetadas? (frontend/backend/fullstack/mobile/devops)",
            "Há dependências externas (libs/serviços) relevantes?",
            "Como será validado (tests, comando, URL)?"
          ]
          answers = ask_series(q)
          args.scope = args.scope || answers[0]
          args.description = args.description || ("Escopo: " + (answers[0]||""))
          args.area = args.area || normalize_area(answers[2]) || "fullstack"

          // Gerar título curto em modo imperativo a partir do escopo
          args.title = generate_title_from_scope(args.scope, lang)
        } else {
          // Se o título foi fornecido, ainda coletar critérios mínimos
          answers = ask_series([
            "Descreva brevemente o escopo e o resultado esperado (1-2 linhas).",
            "Critérios de aceitação?",
            "Arquivos/pastas prováveis a tocar?",
            "Dependências (libs/serviços)?",
            "Forma de validação (tests/comandos/URL)?"
          ])
          args.scope = args.scope || answers[0]
          args.description = args.description || ("Escopo: " + (answers[0]||""))
          args.area = args.area || "fullstack"
        }
        ]]>
      </logic>
    </step>

    <step id="5.derive_workspace_context">
      <goal>Inferir projetos/entrypoints/contexts a partir da Stack (.cappy/stack.md).</goal>
      <logic>
        <![CDATA[
        workspace = { projects: [], runContexts: [] }
        if (stack_md) {
          workspace.projects = parse_projects_from_stack(stack_md) // e.g., [{name, path, type, language}]
          for (p in workspace.projects) {
            rc = recommend_run_context(p) // e.g., {cd: p.path, env: [], build: [], test: [], run: []}
            workspace.runContexts.push(rc)
          }
        }
        // If multiple projects (e.g., web and api), keep both contexts and document navigation commands
        ]]>
      </logic>
      <output>internal.workspace</output>
    </step>

    <step id="6.generate_filename">
      <goal>Gerar nome do arquivo usando timestamp e título em kebab-case.</goal>
      <logic>
        <![CDATA[
        ts = unix_timestamp()
        kebab = kebab_case(args.title)
        filename = `STEP_${ts}_${kebab}.xml`
        outpath = `.cappy/tasks/${filename}`
        ]]>
      </logic>
    </step>

    <step id="7.write_task_xml">
      <goal>Write the task XML with required structure and defaults (status=preparing).</goal>
      <template>
        <![CDATA[
<task id="{{ kebab }}" version="1.0">
  <metadata>
    <title>{{ args.title }}</title>
    <description>{{ args.description || ("Atomic task: " + args.title) }}</description>
    <status>preparing</status>
    <progress>0/1</progress>
  </metadata>
  <context>
    <area>{{ args.area }}</area>
    <technology main="{{ args.tech || 'unknown' }}" version=""/>
    <step id="7.write_task_xml">
      <goal>Escrever o XML da task com defaults (status=preparing) sem executar nada.</goal>
    </dependencies>
    <files>
      <!-- Enumerate files once known during execution; empty on creation is acceptable -->
    </files>
  </context>
  <steps>
    <step id="step001" order="1" completed="false" required="true">
      <title>Describe the concrete outcome</title>
      <description>Define the first concrete implementation step for this task.</description>
      <criteria>
        <criterion>Build succeeds</criterion>
        <criterion>Unit test(s) for this step pass</criterion>
      </criteria>
      <files>
        <!-- Add file paths touched by this step when known -->
      </files>
      <dependencies>
        <!-- Optional per-step dependencies -->
      </dependencies>
      <validation>
        <command>npm run test</command>
        <metric>tests_passed >= 1</metric>
      </validation>
    </step>
  </steps>
  <validation>
    <checklist>
      <item>All required steps completed</item>
      <item>All required files created</item>
      <item>Code compiles without errors</item>
      <item>No linting warnings</item>
    </checklist>
  </validation>
</task>
        ]]>
      </template>
      <logic>
        <![CDATA[
        xml = render_template(template, { args, kebab })
        write_file(outpath, xml)
        ]]>
      </logic>
    </step>

    <step id="8.embed_preparation_notes">
      <goal>Acrescentar seção de preparação com Q&A do escopo e contexts de execução.</goal>
      <logic>
        <![CDATA[
        xml = read_text(outpath)
        prep = `\n  <!-- preparation -->\n  <preparation>\n    <scope>\n      <summary>${last_answers[0]||''}</summary>\n      <acceptance>${last_answers[1]||''}</acceptance>\n      <areas>${args.area||''}</areas>\n      <paths>${last_answers[2]||''}</paths>\n      <dependencies>${last_answers[3]||''}</dependencies>\n      <validation>${last_answers[4]||''}</validation>\n    </scope>\n    <workspace>\n      ${JSON.stringify(internal.workspace || {}, null, 2)}\n    </workspace>\n  </preparation>`
        xml = xml.replace(/<validation>[\s\S]*?<\/validation>[\r\n]*<\/task>/, (m)=> m.replace('</task>', prep + "\n</task>"))
        write_file(outpath, xml)
        ]]>
      </logic>
    </step>

    <step id="9.mark_prepared">
      <goal>Marcar como preparada e salvar ponteiro de task atual.</goal>
      <logic>
        <![CDATA[
        // Update status to prepared
        xml = read_text(outpath)
        xml = xml.replace('<status>preparing</status>', '<status>prepared</status>')
        write_file(outpath, xml)

        // Save current task pointer
        ensure_dir('.cappy/state')
        state = { currentTaskFile: outpath, status: 'prepared', updatedAt: now_iso() }
        write_file('.cappy/state/current-task.json', JSON.stringify(state, null, 2))
        ]]>
      </logic>
    </step>

    <step id="10.confirm">
      <goal>Confirmar criação e preparação. Aguardar próximo comando.</goal>
      <logic>
        <![CDATA[
        say(`Task preparada: ${filename}\nLocal: ${outpath}\nPróximo: use 'cappy:run exe:' com o run context adequado.`)
        ]]>
      </logic>
    </step>
  </steps>
</cappy:script>
