<?xml version="1.0" encoding="UTF-8"?>
<cappy:script name="view-current-task" version="1.0">
  <about>
    <summary>Exibir o status da task atual (progresso, próximo step, arquivos e ações).</summary>
    <command>cappy:task:status</command>
    <notes>
      <note>Não altera nenhum arquivo; apenas lê .cappy/tasks/ e apresenta status.</note>
    </notes>
  </about>

  <steps>
    <step id="1.find_active_task">
      <goal>Localizar a task ativa em .cappy/tasks/.</goal>
      <logic>
        <![CDATA[
        // 1) Tentar usar o ponteiro de estado
        active_task = null
        state = optional_read_json('.cappy/state/current-task.json')
        if (state && state.currentTaskFile) {
          try {
            xml = parse_xml(read_file(state.currentTaskFile))
            active_task = { xml, task_file: state.currentTaskFile }
          } catch (e) { /* fallback para varredura */ }
        }

        // 2) Fallback: varrer tasks
        if (!active_task) {
          tasks = list_files(".cappy/tasks/*.xml")
          for (task_file in tasks) {
            xml = parse_xml(read_file(task_file))
            if (xml.metadata.status in ["em-andamento", "in-progress", "prepared", "preparing"]) {
              // Preferir a que estiver em-andamento; caso contrário, pegar a mais recente
              if (xml.metadata.status == "em-andamento" || xml.metadata.status == "in-progress") { active_task = { xml, task_file }; break }
              active_task = { xml, task_file }
            }
          }
        }

        if (!active_task) {
          say("❌ Nenhuma task ativa encontrada. Use 'cappy:newtask' para criar e preparar uma task.")
          return
        }
        ]]>
      </logic>
      <output>internal.activeTask</output>
    </step>

    <step id="2.analyze_progress">
      <goal>Calcular progresso, identificar próximo step e dependências.</goal>
      <logic>
        <![CDATA[
        xml = internal.activeTask.xml
        total_steps = count(xml.steps.step)
        completed_steps = count_where(xml.steps.step, "completed=true|concluido=true")
        current_step = find_first_where(xml.steps.step, "completed=false|concluido=false")
        progress_percentage = total_steps > 0 ? round((completed_steps / total_steps) * 100) : 0

        analysis = { total_steps, completed_steps, current_step, progress_percentage }

        // Dependência do step atual (se houver)
        if (current_step && current_step['dependsOn|dependeDe']) {
          dep_id = current_step['dependsOn|dependeDe']
          dep_step = find_step_by_id(xml.steps.step, dep_id)
          if (dep_step && (dep_step.completed == false || dep_step.concluido == false)) {
            analysis.dependencyWarning = "⚠️ Step atual depende de: " + (dep_step.title || dep_step.titulo || dep_id)
          }
        }

        internal.taskAnalysis = analysis
        ]]>
      </logic>
      <output>internal.taskAnalysis</output>
    </step>

    <step id="3.present_status">
      <goal>Apresentar o status atual de forma clara e objetiva.</goal>
      <logic>
        <![CDATA[
        xml = internal.activeTask.xml
        analysis = internal.taskAnalysis
        title = xml.metadata.title || xml.metadados.titulo || "(sem título)"
        status = xml.metadata.status || xml.metadados.status || "(sem status)"
        progress = `${analysis.completed_steps}/${analysis.total_steps} steps (${analysis.progress_percentage}%)`

        current = analysis.current_step || {}
        step_title = current.title || current.titulo || "(sem título)"
        step_desc  = current.description || current.descricao || "(sem descrição)"

        // Construir lista de critérios
        criterios = []
        if (current.criteria && current.criteria.criterion) criterios = as_array(current.criteria.criterion)
        if (current.criterios && current.criterios.criterio) criterios = as_array(current.criterios.criterio)

        // Arquivos envolvidos
        files = []
        if (current.files && current.files.file) files = as_array(current.files.file)
        if (current.entrega) files = files.concat(as_array(current.entrega))

        // Saída amigável
        say(`# 📋 Task Atual: ${title}\n\n## 📈 Progresso Geral\n- Status: ${status}\n- Progresso: ${progress}\n\n## 📍 Próximo Step\n${step_title}\n🎯 Objetivo: ${step_desc}\n\n✅ Critérios para conclusão:`)
        for (c in criterios) { say(`- ${c}`) }

        if (files.length > 0) {
          say("\n## 📁 Arquivos Envolvidos")
          for (f in files) { say(`- ${f}`) }
        }

        if (analysis.dependencyWarning) {
          say(`\n${analysis.dependencyWarning}`)
        }

        say("\n## 🚀 Ações Disponíveis\n- 'vamos trabalhar' — Iniciar execução do step atual\n- 'marcar step como concluído' — Finalizar step atual\n- 'pausar task' — Pausar a task temporariamente")
        ]]>
      </logic>
    </step>

    <step id="4.show_prevention_rules">
      <goal>Exibir Prevention Rules relevantes, se houver.</goal>
      <logic>
        <![CDATA[
        rules = optional_read(".cappy/prevention-rules.md")
        if (rules) {
          // Não filtra por área aqui para manter simples; implementações podem evoluir o filtro
          say("\n## 🛡️ Prevention Rules Aplicáveis")
          say(rules)
        }
        ]]>
      </logic>
    </step>
  </steps>
</cappy:script>
